#!/usr/bin/env node

require('babel-register')({
  ignore: false,
  "presets": ["react"]
});
const CWD = process.cwd();
const express = require('express');
const React = require('react');
const renderToStaticMarkup = require('react-dom/server').renderToStaticMarkup;
const fs = require('fs-extra');
const os = require('os');
const path = require('path');
const readMetadata = require('./readMetadata.js');
const toSlug = require('../core/toSlug.js');
const mkdirp = require('mkdirp');
let siteConfig = require(CWD + '/siteConfig.js');

/* https://stackoverflow.com/questions/9210542/node-js-require-cache-possible-to-invalidate */
/**
 * Removes a module from the cache
 */
function purgeCache(moduleName) {
  // Traverse the cache looking for the files
  // loaded by the specified module name
  searchCache(moduleName, function (mod) {
    delete require.cache[mod.id];
  });

  // Remove cached paths to the module.
  // Thanks to @bentael for pointing this out.
  Object.keys(module.constructor._pathCache).forEach(function (cacheKey) {
    if (cacheKey.indexOf(moduleName) > 0) {
      delete module.constructor._pathCache[cacheKey];
    }
  });
};

/**
 * Traverses the cache to search for all the cached
 * files of the specified module name
 */
function searchCache(moduleName, callback) {
  // Resolve the module identified by the specified name
  let mod = require.resolve(moduleName);

  // Check if the module has been resolved and found within
  // the cache
  if (mod && (mod = require.cache[mod]) !== undefined) {
    // Recursively go over the results
    (function traverse(mod) {
      // Go over each of the module's children and
      // traverse them
      mod.children.forEach(function (child) {
        traverse(child);
      });

      // Call the specified callback providing the
      // found cached module
      callback(mod);
    })(mod);
  }
};

/****************************************************************************/

let Metadata;
let readCategories;

function reloadMetadataCategories() {
  readMetadata.generateAll();
  purgeCache('../core/metadata.js');
  Metadata = require('../core/metadata.js');
  purgeCache('./readCategories.js');
  readCategories = require('./readCategories.js');

  let layouts = {};
  for (let i = 0; i < Metadata.length; i++) {
    let layout = Metadata[i].layout;
    if (layouts[layout] !== true) {
      layouts[layout] = true;
      readCategories(layout);
    }
  }
}

/****************************************************************************/

const TABLE_OF_CONTENTS_TOKEN = '<AUTOGENERATED_TABLE_OF_CONTENTS>';

const insertTableOfContents = rawContent => {
  const regexp = /\n###\s+(`.*`.*)\n/g;
  let match;
  const headers = [];
  while (match = regexp.exec(rawContent)) {
    headers.push(match[1]);
  }

  const tableOfContents = headers.map(header => `  - [${header}](#${toSlug(header)})`).join('\n');

  return rawContent.replace(TABLE_OF_CONTENTS_TOKEN, tableOfContents);
};

/****************************************************************************/

console.log('server.js triggered...');

const port = 3000;

reloadMetadataCategories();

const app = express().get(/docs/, (req, res) => {
  purgeCache(CWD + '/siteConfig.js');
  siteConfig = require(CWD + '/siteConfig.js');

  console.log(req.path);

  reloadMetadataCategories();
  let links = {};
  for (let i = 0; i < Metadata.length; i++) {
    const metadata = Metadata[i];
    links[metadata.permalink] = 'docs/' + metadata.language + '/' + metadata.source;
  }
  let mdToHtml = {};
  for (let i = 0; i < Metadata.length; i++) {
    const metadata = Metadata[i];
    mdToHtml['/docs/' + metadata.language + '/' + metadata.source] = siteConfig.baseUrl + metadata.permalink;
  }

  let file = links[req.path.toString().replace(siteConfig.baseUrl, '')];
  file = CWD + '/../' + file;
  console.log(file);
  const result = readMetadata.processMetadata(file);

  let language = 'en';
  const metadata = result.metadata;
  let rawContent = result.rawContent;

  /* generate table of contents if appropriate */
  if (rawContent && rawContent.indexOf(TABLE_OF_CONTENTS_TOKEN) !== -1) {
    rawContent = insertTableOfContents(rawContent);
  }

  /* replace any links to markdown files to their website html links */
  Object.keys(mdToHtml).forEach(function (key, index) {
    rawContent = rawContent.replace(new RegExp(key, 'g'), mdToHtml[key]);
  });

  purgeCache('../core/DocsLayout.js');
  const DocsLayout = require('../core/DocsLayout.js');
  const docComp = React.createElement(
    DocsLayout,
    { metadata: metadata, language: language, config: siteConfig },
    rawContent
  );

  res.send(renderToStaticMarkup(docComp));
});

app.get('*.html', (req, res) => {
  purgeCache(CWD + '/siteConfig.js');
  siteConfig = require(CWD + '/siteConfig.js');

  console.log(req.path);
  let file = req.path.toString().replace(/\.html$/, '.js');
  file = file.replace(siteConfig.baseUrl, '');
  userFile = CWD + '/src/' + file;
  defaultFile = __dirname + '/../src/' + file;

  let language = 'en';

  if (fs.existsSync(userFile) || fs.existsSync(userFile = userFile.replace(path.basename(userFile), 'en/' + path.basename(userFile)))) {

    /* copy into docusaurus so require paths work */
    let parts = userFile.split('src/');
    let tempFile = __dirname + '/../src/' + parts[1];
    tempFile = tempFile.replace(path.basename(file), 'temp' + path.basename(file));
    mkdirp.sync(tempFile.replace(new RegExp('/[^/]*$'), ''));
    fs.copySync(userFile, tempFile);

    /* render into a string */
    purgeCache(tempFile);
    const ReactComp = require(tempFile);
    purgeCache('../core/Site.js');
    const Site = require('../core/Site.js');
    const str = renderToStaticMarkup(React.createElement(
      Site,
      { language: language, config: siteConfig },
      React.createElement(ReactComp, null)
    ));

    fs.removeSync(tempFile);

    res.send(str);
  } else if (fs.existsSync(defaultFile)) {
    purgeCache(defaultFile);
    const ReactComp = require(defaultFile);
    purgeCache('../core/Site.js');
    const Site = require('../core/Site.js');
    res.send(renderToStaticMarkup(React.createElement(
      Site,
      { language: language, config: siteConfig },
      React.createElement(ReactComp, null)
    )));
  } else {
    console.log(req.path);
    res.send('No file found');
  }
});

app.get('/', (req, res) => {
  res.redirect('/index.html');
});
app.get(siteConfig.baseUrl, (req, res) => {
  res.redirect('/index.html');
});

app.get('*.css', (req, res) => {
  let filePath = req.path.toString().replace(siteConfig.baseUrl, '/');
  let cssContent;
  if (fs.existsSync(CWD + '/src' + filePath)) {
    cssContent = fs.readFileSync(CWD + '/src' + filePath);
  } else if (fs.existsSync(__dirname + '/../src' + filePath)) {
    cssContent = fs.readFileSync(__dirname + '/../src' + filePath);
  } else {
    res.send('No File Found');
    return;
  }
  cssContent = cssContent.toString().replace(new RegExp('{primaryColor}', 'g'), siteConfig.colors.primaryColor);
  cssContent = cssContent.replace(new RegExp('{secondaryColor}', 'g'), siteConfig.colors.secondaryColor);
  cssContent = cssContent.replace(new RegExp('{prismColor}', 'g'), siteConfig.colors.prismColor);

  res.send(cssContent);
});

app.use(siteConfig.baseUrl, express.static(CWD + '/src'));
app.use(siteConfig.baseUrl, express.static(__dirname + '/../src'));

app.listen(port);
console.log('listening on port: ' + port);